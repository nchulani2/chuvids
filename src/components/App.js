import React from 'react';
import youtube from '../api/youtube';
import Navigational from './Navigational';
import VideoList from './VideoList';
import VideoContent from './VideoContent';
import Footer from './Footer';

const apiKey = {
  youKey: process.env.REACT_APP_YOUTUBE_KEY
};

export default class App extends React.Component {
  state = {
    userInp: '',
    videos: [],
    nextPage: '',
    prevPage: '',
    totalVideos: 0,
    // channels isn't actually rendered, it's just there
    channels: [],
    // default video
    specVidId: 'Ig1dbRdlFS0',
    specVidTitle: 'Rainforest (Original Mix)',
    specVidDesc: `Provided to YouTube by Label Worx Ltd \n\n Rainforest (Original Mix) · Saib\n\n Mangroves \n\n ℗ Chillhop Publishing \n\n Released on: 2019-05-20\n\n Composer: Hamza Saib \n\n Auto-generated by YouTube.`
  };
  // HANDLES CLICKING A VIDEO
  handleSpecificVid = async (id, title) => {
    try {
      const vidResponse = await youtube.get(`youtube/v3/videos`, {
        params: {
          part: 'snippet',
          id: id,
          key: apiKey.youKey
        }
      });
      this.setState({
        specVidId: id,
        specVidTitle: title,
        specVidDesc: vidResponse.data.items[0].snippet.description
      });
    } catch (err) {
      alert(err);
    }
  };

  // HANDLES NEXT VIDEO AFTER PLAYING
  handleNextVid = async e => {
    var vidData = e.target.getVideoData();

    // get the next vid ID
    var vidId;
    var vidTitle;
    for (let index = 0; index < this.state.videos.length - 1; index++) {
      if (this.state.videos[index].id.videoId === vidData.video_id) {
        vidId = this.state.videos[index + 1].id.videoId;
        vidTitle = this.state.videos[index + 1].snippet.title;
      }
    }
    // Make a req to get that next vid's description
    this.handleSpecificVid(vidId, vidTitle);
  };

  // INITIAL LOAD & HANDLES SEARCH INPUT
  handleApiCall = async userInput => {
    if (userInput === this.state.userInp) return;

    try {
      const response = await youtube.get(`youtube/v3/search`, {
        params: {
          part: 'snippet',
          maxResults: 10,
          q: userInput,
          key: apiKey.youKey
        }
      });

      // filter channels from vids
      const vidArray = [];
      const channels = [];
      response.data.items.forEach(element => {
        if (element.id.videoId) {
          vidArray.push(element);
        } else {
          channels.push(element);
        }
      });

      this.setState({
        videos: vidArray,
        channels: channels,
        totalVideos: response.data.pageInfo.totalResults,
        nextPage: response.data.nextPageToken,
        userInp: userInput
      });
    } catch (err) {
      alert(err);
    }
  };

  goForward = async () => {
    // if (this.state.videos.length === 0) {
    // const pagiRight = document.querySelector('.buttonParTwo');
    // pagiRight.classList.
    // }

    try {
      const response = await youtube.get(`youtube/v3/search`, {
        params: {
          part: 'snippet',
          maxResults: 10,
          pageToken: this.state.nextPage,
          q: this.state.userInp,
          key: apiKey.youKey
        }
      });

      // filter channels from vids
      const vidArray = [];
      const channels = [];
      response.data.items.forEach(element => {
        if (element.id.videoId) {
          vidArray.push(element);
        } else {
          channels.push(element);
        }
      });

      this.setState({
        videos: vidArray,
        channels: channels,
        totalVideos: response.data.pageInfo.totalResults,
        nextPage: response.data.nextPageToken,
        prevPage: response.data.prevPageToken
      });
    } catch (err) {
      alert(err);
    }
  };

  goBack = async () => {
    if (this.state.videos.length === 0) return;

    try {
      const response = await youtube.get(`youtube/v3/search`, {
        params: {
          part: 'snippet',
          maxResults: 10,
          pageToken: this.state.prevPage,
          q: this.state.userInp,
          key: apiKey.youKey
        }
      });

      // filter channels from vids
      const vidArray = [];
      const channels = [];
      response.data.items.forEach(element => {
        if (element.id.videoId) {
          vidArray.push(element);
        } else {
          channels.push(element);
        }
      });
      // if (response.data.prevPageToken === undefined) return;
      this.setState({
        videos: vidArray,
        channels: channels,
        totalVideos: response.data.pageInfo.totalResults,
        nextPage: response.data.nextPageToken,
        prevPage: response.data.prevPageToken
      });
    } catch (err) {
      alert(err);
    }
  };

  // initial call to api for default vids to be rendered
  componentDidMount = () => {
    this.handleApiCall('rainforest saib');
    window.addEventListener(
      'touchmove',
      function(event) {
        event.preventDefault();
      },
      { passive: false }
    );
    const app = document.querySelector('.index');
    app.addEventListener(
      'touchmove',
      function(event) {
        event.stopPropagation();
      },
      { passive: false }
    );
  };

  render() {
    return (
      <div className="app-body animated fadeIn delay-0s ">
        <Navigational handleCall={this.handleApiCall} />
        <div className="ui container">
          <VideoList
            handleGoBack={this.goBack}
            handleGoForward={this.goForward}
            videoQuant={this.state.videos}
            totalVids={this.state.totalVideos}
            onSelectVid={this.handleSpecificVid}>
            <VideoContent
              theVidId={this.state.specVidId}
              theVidTitle={this.state.specVidTitle}
              theVidDesc={this.state.specVidDesc}
              onEndedVid={this.handleNextVid}
            />
          </VideoList>
        </div>
        <Footer />
      </div>
    );
  }
}
